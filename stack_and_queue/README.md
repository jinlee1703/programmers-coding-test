# 스택/큐

## Solution1. 같은 숫자는 싫어

- peek라는 변수를 통해 스택의 최상단 위치를 저장하고, Integer 배열을 구현하여 풀었다.
- 다만 출력이 귀찮아서 ArrayList를 선언하여 풀었는데, 이 부분은 시간도 낭비하고, 좋은 코드는 아닌거 같다.

## Solution2. 기능개발

- `java.util.Queue` 자료구조 라이브러리를 사용하여 작업 번호를 큐에 저장하였다.
- while 반복문으로 `day` 변수를 1씩 증가시키고, 2중 while 반복문으로 queue의 peek()를 통해 작업의 완료여부를 체크하고, 다음 peek()를 체크하는 방식으로 구현하였다.
- 작업이 완료되면 `deployCount` 변수를 증가시키고, day 별로 `deployCount`가 1 이상이면 `java.util.ArrayList` 자료구조에 추가하고 최종적으로 이를 반환하였다.

## Solution3. 올바른 괄호

- 자료구조 라이브러리(`java.util.Stack`)를 사용하여 풀었으나, 효율성 검사에 통과하지 못하여 수정하였다.
- `String.split()` 메서드를 사용하여 풀었으나 효율성 검사에 통과하지 못하여, s.toCharArray()를 사용하여 풀었다. => 이 방법으로 통과하였다.
- 이 문제의 경우에는 괄호의 종류가 1개이기 때문에 String이나 int 변수의 stack(배열)을 사용하지 않고 boolean으로 구현하였다.

## Solution4. 프로세스

- 자료구조 라이브러리(`java.util.Queue`)를 사용하여 풀었다.
- 우선 `int`형 배열인 `priorities`의 원소들을 큐에 추가해주었다.
- 큐의 최대값을 구하고 원소를 제거한 후 해당 원소가 최대값과 일치하면 제거한 상태로 유지, 일치하지 않는다면, 큐의 맨 뒤에 다시 넣어주도록 하였다.
- 만약 제거한 원소가 location과 일치한다면 while 반복문을 종료해준다.
- 여기서 사용자가 찾는 원소의 번호인 `location`은 큐에서 찾으려는 원소의 현재 위치를 가르키기 때문에 큐에서 원소가 제거될 때마다 -1 해주도록 구현하였다.
- 제거한 원소가 max와 일치하고, 만약 location이 0이라면 문제에서 찾던 원소이므로 while 반복문을 종료한다.